
Whatever.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000432  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003c  00800060  00000432  000004c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000003  0080009c  0080009c  00000502  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000502  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000118  00000000  00000000  00000532  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000ceb  00000000  00000000  0000064a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000624  00000000  00000000  00001335  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000065c  00000000  00000000  00001959  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000268  00000000  00000000  00001fb8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000361  00000000  00000000  00002220  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006ca  00000000  00000000  00002581  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000f0  00000000  00000000  00002c4b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 4e 01 	jmp	0x29c	; 0x29c <__vector_8>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 5f 01 	jmp	0x2be	; 0x2be <__vector_16>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 e3       	ldi	r30, 0x32	; 50
  68:	f4 e0       	ldi	r31, 0x04	; 4
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ac 39       	cpi	r26, 0x9C	; 156
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	ac e9       	ldi	r26, 0x9C	; 156
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	af 39       	cpi	r26, 0x9F	; 159
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 cc 01 	call	0x398	; 0x398 <main>
  8a:	0c 94 17 02 	jmp	0x42e	; 0x42e <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <lcd_putint>:
#include "LCD.h"

/************************************************************************/
/*                                                                      */
/************************************************************************/
void lcd_putint(uint16_t input){
  92:	1f 93       	push	r17
  94:	cf 93       	push	r28
  96:	df 93       	push	r29
  98:	ec 01       	movw	r28, r24
	char c= 15; //eppen melyik karakterpozicional vagyunk		
  9a:	8f e0       	ldi	r24, 0x0F	; 15
	
	do{
		lcd_gotoxy(c--, 1);
  9c:	1f ef       	ldi	r17, 0xFF	; 255
  9e:	18 0f       	add	r17, r24
  a0:	61 e0       	ldi	r22, 0x01	; 1
  a2:	0e 94 c0 00 	call	0x180	; 0x180 <lcd_gotoxy>
		lcd_putc('0' + (input%10));
  a6:	9e 01       	movw	r18, r28
  a8:	ad ec       	ldi	r26, 0xCD	; 205
  aa:	bc ec       	ldi	r27, 0xCC	; 204
  ac:	0e 94 08 02 	call	0x410	; 0x410 <__umulhisi3>
  b0:	96 95       	lsr	r25
  b2:	87 95       	ror	r24
  b4:	96 95       	lsr	r25
  b6:	87 95       	ror	r24
  b8:	96 95       	lsr	r25
  ba:	87 95       	ror	r24
  bc:	9c 01       	movw	r18, r24
  be:	22 0f       	add	r18, r18
  c0:	33 1f       	adc	r19, r19
  c2:	88 0f       	add	r24, r24
  c4:	99 1f       	adc	r25, r25
  c6:	88 0f       	add	r24, r24
  c8:	99 1f       	adc	r25, r25
  ca:	88 0f       	add	r24, r24
  cc:	99 1f       	adc	r25, r25
  ce:	82 0f       	add	r24, r18
  d0:	93 1f       	adc	r25, r19
  d2:	9e 01       	movw	r18, r28
  d4:	28 1b       	sub	r18, r24
  d6:	39 0b       	sbc	r19, r25
  d8:	c9 01       	movw	r24, r18
  da:	80 5d       	subi	r24, 0xD0	; 208
  dc:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_putc>
		input/= 10;
  e0:	9e 01       	movw	r18, r28
  e2:	ad ec       	ldi	r26, 0xCD	; 205
  e4:	bc ec       	ldi	r27, 0xCC	; 204
  e6:	0e 94 08 02 	call	0x410	; 0x410 <__umulhisi3>
  ea:	ec 01       	movw	r28, r24
  ec:	d6 95       	lsr	r29
  ee:	c7 95       	ror	r28
  f0:	d6 95       	lsr	r29
  f2:	c7 95       	ror	r28
  f4:	d6 95       	lsr	r29
  f6:	c7 95       	ror	r28
	}while (input != 0);
  f8:	20 97       	sbiw	r28, 0x00	; 0
  fa:	11 f0       	breq	.+4      	; 0x100 <lcd_putint+0x6e>
/************************************************************************/
void lcd_putint(uint16_t input){
	char c= 15; //eppen melyik karakterpozicional vagyunk		
	
	do{
		lcd_gotoxy(c--, 1);
  fc:	81 2f       	mov	r24, r17
  fe:	ce cf       	rjmp	.-100    	; 0x9c <lcd_putint+0xa>
		lcd_putc('0' + (input%10));
		input/= 10;
	}while (input != 0);
 100:	df 91       	pop	r29
 102:	cf 91       	pop	r28
 104:	1f 91       	pop	r17
 106:	08 95       	ret

00000108 <toggle_e>:

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
 108:	96 9a       	sbi	0x12, 6	; 18
    lcd_e_delay();
 10a:	00 c0       	rjmp	.+0      	; 0x10c <toggle_e+0x4>
    lcd_e_low();
 10c:	96 98       	cbi	0x12, 6	; 18
 10e:	08 95       	ret

00000110 <lcd_write>:
                 0: write instruction
Returns:  none
*************************************************************************/
#if LCD_IO_MODE
static void lcd_write(uint8_t data,uint8_t rs) 
{
 110:	cf 93       	push	r28
 112:	c8 2f       	mov	r28, r24
    unsigned char dataBits ;


    if (rs) {   /* write data        (RS=1, RW=0) */
 114:	66 23       	and	r22, r22
 116:	11 f0       	breq	.+4      	; 0x11c <lcd_write+0xc>
       lcd_rs_high();
 118:	97 9a       	sbi	0x12, 7	; 18
 11a:	01 c0       	rjmp	.+2      	; 0x11e <lcd_write+0xe>
    } else {    /* write instruction (RS=0, RW=0) */
       lcd_rs_low();
 11c:	97 98       	cbi	0x12, 7	; 18
        LCD_DATA0_PORT = dataBits | 0x0F;
    }
    else
    {
        /* configure data pins as output */
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
 11e:	8d 9a       	sbi	0x11, 5	; 17
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
 120:	8c 9a       	sbi	0x11, 4	; 17
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
 122:	8b 9a       	sbi	0x11, 3	; 17
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
 124:	8a 9a       	sbi	0x11, 2	; 17
        
        /* output high nibble first */
        LCD_DATA3_PORT &= ~_BV(LCD_DATA3_PIN);
 126:	92 98       	cbi	0x12, 2	; 18
        LCD_DATA2_PORT &= ~_BV(LCD_DATA2_PIN);
 128:	93 98       	cbi	0x12, 3	; 18
        LCD_DATA1_PORT &= ~_BV(LCD_DATA1_PIN);
 12a:	94 98       	cbi	0x12, 4	; 18
        LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);
 12c:	95 98       	cbi	0x12, 5	; 18
    	if(data & 0x80) LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
 12e:	cc 23       	and	r28, r28
 130:	0c f4       	brge	.+2      	; 0x134 <lcd_write+0x24>
 132:	92 9a       	sbi	0x12, 2	; 18
    	if(data & 0x40) LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
 134:	c6 fd       	sbrc	r28, 6
 136:	93 9a       	sbi	0x12, 3	; 18
    	if(data & 0x20) LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
 138:	c5 fd       	sbrc	r28, 5
 13a:	94 9a       	sbi	0x12, 4	; 18
    	if(data & 0x10) LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);   
 13c:	c4 fd       	sbrc	r28, 4
 13e:	95 9a       	sbi	0x12, 5	; 18
        lcd_e_toggle();
 140:	0e 94 84 00 	call	0x108	; 0x108 <toggle_e>
        
        /* output low nibble */
        LCD_DATA3_PORT &= ~_BV(LCD_DATA3_PIN);
 144:	92 98       	cbi	0x12, 2	; 18
        LCD_DATA2_PORT &= ~_BV(LCD_DATA2_PIN);
 146:	93 98       	cbi	0x12, 3	; 18
        LCD_DATA1_PORT &= ~_BV(LCD_DATA1_PIN);
 148:	94 98       	cbi	0x12, 4	; 18
        LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);
 14a:	95 98       	cbi	0x12, 5	; 18
    	if(data & 0x08) LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
 14c:	c3 fd       	sbrc	r28, 3
 14e:	92 9a       	sbi	0x12, 2	; 18
    	if(data & 0x04) LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
 150:	c2 fd       	sbrc	r28, 2
 152:	93 9a       	sbi	0x12, 3	; 18
    	if(data & 0x02) LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
 154:	c1 fd       	sbrc	r28, 1
 156:	94 9a       	sbi	0x12, 4	; 18
    	if(data & 0x01) LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
 158:	c0 fd       	sbrc	r28, 0
 15a:	95 9a       	sbi	0x12, 5	; 18
        lcd_e_toggle();        
 15c:	0e 94 84 00 	call	0x108	; 0x108 <toggle_e>
        
        /* all data pins high (inactive) */
        LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
 160:	95 9a       	sbi	0x12, 5	; 18
        LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
 162:	94 9a       	sbi	0x12, 4	; 18
        LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
 164:	93 9a       	sbi	0x12, 3	; 18
        LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
 166:	92 9a       	sbi	0x12, 2	; 18
    }
}
 168:	cf 91       	pop	r28
 16a:	08 95       	ret

0000016c <lcd_command>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 16c:	ef e1       	ldi	r30, 0x1F	; 31
 16e:	fe e4       	ldi	r31, 0x4E	; 78
 170:	31 97       	sbiw	r30, 0x01	; 1
 172:	f1 f7       	brne	.-4      	; 0x170 <lcd_command+0x4>
 174:	00 c0       	rjmp	.+0      	; 0x176 <lcd_command+0xa>
 176:	00 00       	nop
Returns: none
*************************************************************************/
void lcd_command(uint8_t cmd)
{
    lcd_waitbusy();
    lcd_write(cmd,0);
 178:	60 e0       	ldi	r22, 0x00	; 0
 17a:	0e 94 88 00 	call	0x110	; 0x110 <lcd_write>
 17e:	08 95       	ret

00000180 <lcd_gotoxy>:
{
#if LCD_LINES==1
    lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
#endif
#if LCD_LINES==2
    if ( y==0 ) 
 180:	61 11       	cpse	r22, r1
 182:	04 c0       	rjmp	.+8      	; 0x18c <lcd_gotoxy+0xc>
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
 184:	80 58       	subi	r24, 0x80	; 128
 186:	0e 94 b6 00 	call	0x16c	; 0x16c <lcd_command>
 18a:	08 95       	ret
    else
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE2+x);
 18c:	80 54       	subi	r24, 0x40	; 64
 18e:	0e 94 b6 00 	call	0x16c	; 0x16c <lcd_command>
 192:	08 95       	ret

00000194 <lcd_clrscr>:
/*************************************************************************
Clear display and set cursor to home position
*************************************************************************/
void lcd_clrscr(void)
{
    lcd_command(1<<LCD_CLR);
 194:	81 e0       	ldi	r24, 0x01	; 1
 196:	0e 94 b6 00 	call	0x16c	; 0x16c <lcd_command>
 19a:	08 95       	ret

0000019c <lcd_putc>:
 19c:	ef e1       	ldi	r30, 0x1F	; 31
 19e:	fe e4       	ldi	r31, 0x4E	; 78
 1a0:	31 97       	sbiw	r30, 0x01	; 1
 1a2:	f1 f7       	brne	.-4      	; 0x1a0 <lcd_putc+0x4>
 1a4:	00 c0       	rjmp	.+0      	; 0x1a6 <lcd_putc+0xa>
 1a6:	00 00       	nop
void lcd_putc(char c)
{
    uint8_t pos;
	pos = lcd_waitbusy();   // read busy-flag and address counter
    
	if (c=='\n')
 1a8:	8a 30       	cpi	r24, 0x0A	; 10
 1aa:	21 f4       	brne	.+8      	; 0x1b4 <lcd_putc+0x18>
		#else
	    addressCounter = LCD_START_LINE1;
		#endif
	}
#endif
    lcd_command((1<<LCD_DDRAM)+addressCounter);
 1ac:	80 ec       	ldi	r24, 0xC0	; 192
 1ae:	0e 94 b6 00 	call	0x16c	; 0x16c <lcd_command>
 1b2:	08 95       	ret
    }
    else
    {
		// mtmt changed order to fix autowrap first write to lcd then 
		// check position
		lcd_write(c, 1);
 1b4:	61 e0       	ldi	r22, 0x01	; 1
 1b6:	0e 94 88 00 	call	0x110	; 0x110 <lcd_write>
 1ba:	8f e1       	ldi	r24, 0x1F	; 31
 1bc:	9e e4       	ldi	r25, 0x4E	; 78
 1be:	01 97       	sbiw	r24, 0x01	; 1
 1c0:	f1 f7       	brne	.-4      	; 0x1be <lcd_putc+0x22>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <lcd_putc+0x28>
 1c4:	00 00       	nop
 1c6:	ef e1       	ldi	r30, 0x1F	; 31
 1c8:	fe e4       	ldi	r31, 0x4E	; 78
 1ca:	31 97       	sbiw	r30, 0x01	; 1
 1cc:	f1 f7       	brne	.-4      	; 0x1ca <lcd_putc+0x2e>
 1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <lcd_putc+0x34>
 1d0:	00 00       	nop
 1d2:	08 95       	ret

000001d4 <lcd_puts>:
Input:    string to be displayed
Returns:  none
*************************************************************************/
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
 1d4:	cf 93       	push	r28
 1d6:	df 93       	push	r29
    register char c;

    while ( (c = *s++) ) {
 1d8:	ec 01       	movw	r28, r24
 1da:	21 96       	adiw	r28, 0x01	; 1
 1dc:	fc 01       	movw	r30, r24
 1de:	80 81       	ld	r24, Z
 1e0:	88 23       	and	r24, r24
 1e2:	29 f0       	breq	.+10     	; 0x1ee <lcd_puts+0x1a>
        lcd_putc(c);
 1e4:	0e 94 ce 00 	call	0x19c	; 0x19c <lcd_putc>
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
    register char c;

    while ( (c = *s++) ) {
 1e8:	89 91       	ld	r24, Y+
 1ea:	81 11       	cpse	r24, r1
 1ec:	fb cf       	rjmp	.-10     	; 0x1e4 <lcd_puts+0x10>
        lcd_putc(c);
    }

}/* lcd_puts */
 1ee:	df 91       	pop	r29
 1f0:	cf 91       	pop	r28
 1f2:	08 95       	ret

000001f4 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_ON_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
 1f4:	cf 93       	push	r28
 1f6:	c8 2f       	mov	r28, r24
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    }
    else
    {
        /* configure all port bits as output (LCD data and control lines on different ports */
        DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
 1f8:	8f 9a       	sbi	0x11, 7	; 17
       // DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
 1fa:	8e 9a       	sbi	0x11, 6	; 17
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
 1fc:	8d 9a       	sbi	0x11, 5	; 17
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
 1fe:	8c 9a       	sbi	0x11, 4	; 17
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
 200:	8b 9a       	sbi	0x11, 3	; 17
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
 202:	8a 9a       	sbi	0x11, 2	; 17
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 204:	e0 e0       	ldi	r30, 0x00	; 0
 206:	fd e7       	ldi	r31, 0x7D	; 125
 208:	31 97       	sbiw	r30, 0x01	; 1
 20a:	f1 f7       	brne	.-4      	; 0x208 <lcd_init+0x14>
    }
	
    delay(16000);        /* wait 16ms or more after power-on       */
    
    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);  // _BV(LCD_FUNCTION)>>4;
 20c:	94 9a       	sbi	0x12, 4	; 18
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
 20e:	95 9a       	sbi	0x12, 5	; 18
    lcd_e_toggle();
 210:	0e 94 84 00 	call	0x108	; 0x108 <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 214:	e0 e0       	ldi	r30, 0x00	; 0
 216:	f7 e2       	ldi	r31, 0x27	; 39
 218:	31 97       	sbiw	r30, 0x01	; 1
 21a:	f1 f7       	brne	.-4      	; 0x218 <lcd_init+0x24>
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
    lcd_e_toggle();
    delay(4992);         /* delay, busy flag can't be checked here */
   
    /* repeat last command */ 
    lcd_e_toggle();      
 21c:	0e 94 84 00 	call	0x108	; 0x108 <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 220:	e0 e8       	ldi	r30, 0x80	; 128
 222:	f0 e0       	ldi	r31, 0x00	; 0
 224:	31 97       	sbiw	r30, 0x01	; 1
 226:	f1 f7       	brne	.-4      	; 0x224 <lcd_init+0x30>
    /* repeat last command */ 
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */
    
    /* repeat last command a third time */
    lcd_e_toggle();      
 228:	0e 94 84 00 	call	0x108	; 0x108 <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 22c:	e0 e8       	ldi	r30, 0x80	; 128
 22e:	f0 e0       	ldi	r31, 0x00	; 0
 230:	31 97       	sbiw	r30, 0x01	; 1
 232:	f1 f7       	brne	.-4      	; 0x230 <lcd_init+0x3c>
    /* repeat last command a third time */
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
 234:	95 98       	cbi	0x12, 5	; 18
    lcd_e_toggle();
 236:	0e 94 84 00 	call	0x108	; 0x108 <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 23a:	e0 e8       	ldi	r30, 0x80	; 128
 23c:	f0 e0       	ldi	r31, 0x00	; 0
 23e:	31 97       	sbiw	r30, 0x01	; 1
 240:	f1 f7       	brne	.-4      	; 0x23e <lcd_init+0x4a>
    lcd_write(LCD_FUNCTION_8BIT_1LINE,0);   /* function set: 8bit interface */                 
    delay(64);                              /* wait 64us                    */
    lcd_write(LCD_FUNCTION_8BIT_1LINE,0);   /* function set: 8bit interface */                
    delay(64);                              /* wait 64us                    */
#endif
    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
 242:	88 e2       	ldi	r24, 0x28	; 40
 244:	0e 94 b6 00 	call	0x16c	; 0x16c <lcd_command>
    lcd_command(LCD_DISP_OFF);              /* display off                  */
 248:	88 e0       	ldi	r24, 0x08	; 8
 24a:	0e 94 b6 00 	call	0x16c	; 0x16c <lcd_command>
    lcd_clrscr();                           /* display clear                */ 
 24e:	0e 94 ca 00 	call	0x194	; 0x194 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
 252:	86 e0       	ldi	r24, 0x06	; 6
 254:	0e 94 b6 00 	call	0x16c	; 0x16c <lcd_command>
    lcd_command(dispAttr);                  /* display/cursor control       */
 258:	8c 2f       	mov	r24, r28
 25a:	0e 94 b6 00 	call	0x16c	; 0x16c <lcd_command>

 25e:	cf 91       	pop	r28
 260:	08 95       	ret

00000262 <initUART>:
#include "UART.h"
#include <avr/io.h>

void initUART(){
	 // UBBR be·lÌlt·sa 51-re, 8mhz-en 9600 BAUD
	 UBRRH = 0;                      
 262:	10 bc       	out	0x20, r1	; 32
	 UBRRL = 51;                     
 264:	83 e3       	ldi	r24, 0x33	; 51
 266:	89 b9       	out	0x09, r24	; 9
	 UCSRB|= (1<<TXEN)|(1<<RXEN);                // enable receiver and transmitter
 268:	8a b1       	in	r24, 0x0a	; 10
 26a:	88 61       	ori	r24, 0x18	; 24
 26c:	8a b9       	out	0x0a, r24	; 10
	 UCSRC|= (1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1);   // 8bit data format
 26e:	80 b5       	in	r24, 0x20	; 32
 270:	86 68       	ori	r24, 0x86	; 134
 272:	80 bd       	out	0x20, r24	; 32
 274:	08 95       	ret

00000276 <USARTWriteChar>:
void USARTWriteChar(char data){
	
	//Wait until the transmitter is ready
	//UCSRA: USART control, and status register
	//
	while ((UCSRA & (1<<UDRE)) == 0)
 276:	5d 9b       	sbis	0x0b, 5	; 11
 278:	fe cf       	rjmp	.-4      	; 0x276 <USARTWriteChar>
	{
		//Do nothing
	}
	
	//Write the data to USART buffer
	UDR= data;		
 27a:	8c b9       	out	0x0c, r24	; 12
 27c:	08 95       	ret

0000027e <UARTWriteString>:
	//UDR: USART Data Register
	//Az USART megkapta az adatot, es benne van a bufferben
	return UDR;
}

void UARTWriteString(const char * str){
 27e:	cf 93       	push	r28
 280:	df 93       	push	r29
 282:	ec 01       	movw	r28, r24
	while(*str){
 284:	88 81       	ld	r24, Y
 286:	88 23       	and	r24, r24
 288:	31 f0       	breq	.+12     	; 0x296 <UARTWriteString+0x18>
 28a:	21 96       	adiw	r28, 0x01	; 1
		USARTWriteChar(*str);
 28c:	0e 94 3b 01 	call	0x276	; 0x276 <USARTWriteChar>
	//Az USART megkapta az adatot, es benne van a bufferben
	return UDR;
}

void UARTWriteString(const char * str){
	while(*str){
 290:	89 91       	ld	r24, Y+
 292:	81 11       	cpse	r24, r1
 294:	fb cf       	rjmp	.-10     	; 0x28c <UARTWriteString+0xe>
		USARTWriteChar(*str);
		str++;
	}
}
 296:	df 91       	pop	r29
 298:	cf 91       	pop	r28
 29a:	08 95       	ret

0000029c <__vector_8>:

volatile enum MERES_STATUS megmerte; //a RAMb√≥l val√≥ swappol√°s elkerulesere
											//1, ha a m√©r√©s k√©sz
const char helloString[]= "Kapacitasmero v1.0";

ISR(TIMER1_OVF_vect){
 29c:	1f 92       	push	r1
 29e:	0f 92       	push	r0
 2a0:	0f b6       	in	r0, 0x3f	; 63
 2a2:	0f 92       	push	r0
 2a4:	11 24       	eor	r1, r1
 2a6:	8f 93       	push	r24
	TCCR1B=0;
 2a8:	1e bc       	out	0x2e, r1	; 46
	cli();
 2aa:	f8 94       	cli
	megmerte = TULCSORDULAS;
 2ac:	82 e0       	ldi	r24, 0x02	; 2
 2ae:	80 93 9c 00 	sts	0x009C, r24
}
 2b2:	8f 91       	pop	r24
 2b4:	0f 90       	pop	r0
 2b6:	0f be       	out	0x3f, r0	; 63
 2b8:	0f 90       	pop	r0
 2ba:	1f 90       	pop	r1
 2bc:	18 95       	reti

000002be <__vector_16>:

ISR(ANA_COMP_vect){
 2be:	1f 92       	push	r1
 2c0:	0f 92       	push	r0
 2c2:	0f b6       	in	r0, 0x3f	; 63
 2c4:	0f 92       	push	r0
 2c6:	11 24       	eor	r1, r1
 2c8:	2f 93       	push	r18
 2ca:	3f 93       	push	r19
 2cc:	4f 93       	push	r20
 2ce:	5f 93       	push	r21
 2d0:	6f 93       	push	r22
 2d2:	7f 93       	push	r23
 2d4:	8f 93       	push	r24
 2d6:	9f 93       	push	r25
 2d8:	af 93       	push	r26
 2da:	bf 93       	push	r27
 2dc:	ef 93       	push	r30
 2de:	ff 93       	push	r31
	TCCR1B=0;
 2e0:	1e bc       	out	0x2e, r1	; 46
	cli();
 2e2:	f8 94       	cli
	UARTWriteString("Komparator interrupt\n\r");
 2e4:	80 e6       	ldi	r24, 0x60	; 96
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	0e 94 3f 01 	call	0x27e	; 0x27e <UARTWriteString>
	megmerte = KESZ;
 2ec:	10 92 9c 00 	sts	0x009C, r1
}
 2f0:	ff 91       	pop	r31
 2f2:	ef 91       	pop	r30
 2f4:	bf 91       	pop	r27
 2f6:	af 91       	pop	r26
 2f8:	9f 91       	pop	r25
 2fa:	8f 91       	pop	r24
 2fc:	7f 91       	pop	r23
 2fe:	6f 91       	pop	r22
 300:	5f 91       	pop	r21
 302:	4f 91       	pop	r20
 304:	3f 91       	pop	r19
 306:	2f 91       	pop	r18
 308:	0f 90       	pop	r0
 30a:	0f be       	out	0x3f, r0	; 63
 30c:	0f 90       	pop	r0
 30e:	1f 90       	pop	r1
 310:	18 95       	reti

00000312 <meres>:
uint16_t mert_ido;

char meres(enum TOLTO_ELLENALLAS ezzel){
	// beallitjuk, hogy milyen ellen√°ll√°sokon keresztul toltodjon
	// tri-state: PIN=0-PORT=0
	PORTB = 3;
 312:	93 e0       	ldi	r25, 0x03	; 3
 314:	98 bb       	out	0x18, r25	; 24
	DDRB= (1<<7);
 316:	90 e8       	ldi	r25, 0x80	; 128
 318:	97 bb       	out	0x17, r25	; 23
 31a:	2f ef       	ldi	r18, 0xFF	; 255
 31c:	32 e5       	ldi	r19, 0x52	; 82
 31e:	97 e0       	ldi	r25, 0x07	; 7
 320:	21 50       	subi	r18, 0x01	; 1
 322:	30 40       	sbci	r19, 0x00	; 0
 324:	90 40       	sbci	r25, 0x00	; 0
 326:	e1 f7       	brne	.-8      	; 0x320 <meres+0xe>
 328:	00 c0       	rjmp	.+0      	; 0x32a <meres+0x18>
 32a:	00 00       	nop
	_delay_ms(300); //300msec alatt kisul
	DDRB= 0;
 32c:	17 ba       	out	0x17, r1	; 23
	PORTB = 0;
 32e:	18 ba       	out	0x18, r1	; 24
	//ki van s√ºtve
	
	megmerte = FOLYAMATBAN;	
 330:	91 e0       	ldi	r25, 0x01	; 1
 332:	90 93 9c 00 	sts	0x009C, r25
	
	//Timer init
	//TCCR: Timer Counter Control Register
	//TCNT: Timer Counter
	TCNT1 = 0; //0-r√≥l ekzdj√ºk a sz√°mol√°st
 336:	1d bc       	out	0x2d, r1	; 45
 338:	1c bc       	out	0x2c, r1	; 44
	TIMSK = (1<<TOIE1); //t√∫lcsordul√°sra interrupt
 33a:	94 e0       	ldi	r25, 0x04	; 4
 33c:	99 bf       	out	0x39, r25	; 57
	
	sei();
 33e:	78 94       	sei
	TCCR1B |=  (1<<CS12) | (1<<CS10); // (8MHz/64) -en elind√≠tjuk a sz√°ml√°l√≥t
 340:	9e b5       	in	r25, 0x2e	; 46
 342:	95 60       	ori	r25, 0x05	; 5
 344:	9e bd       	out	0x2e, r25	; 46
	
	switch(ezzel){
 346:	81 30       	cpi	r24, 0x01	; 1
 348:	69 f0       	breq	.+26     	; 0x364 <meres+0x52>
 34a:	80 f0       	brcs	.+32     	; 0x36c <meres+0x5a>
 34c:	82 30       	cpi	r24, 0x02	; 2
 34e:	31 f0       	breq	.+12     	; 0x35c <meres+0x4a>
 350:	83 30       	cpi	r24, 0x03	; 3
 352:	79 f4       	brne	.+30     	; 0x372 <meres+0x60>
		case R1K:
			DDRB =  (1<<4);
 354:	80 e1       	ldi	r24, 0x10	; 16
 356:	87 bb       	out	0x17, r24	; 23
			PORTB = (1<<4);
 358:	88 bb       	out	0x18, r24	; 24
			break;
 35a:	0b c0       	rjmp	.+22     	; 0x372 <meres+0x60>
		case R10K:
			DDRB =  (1<<5);
 35c:	80 e2       	ldi	r24, 0x20	; 32
 35e:	87 bb       	out	0x17, r24	; 23
			PORTB = (1<<5);
 360:	88 bb       	out	0x18, r24	; 24
			break;
 362:	07 c0       	rjmp	.+14     	; 0x372 <meres+0x60>
		case R100K:
			DDRB =  (1<<6);
 364:	80 e4       	ldi	r24, 0x40	; 64
 366:	87 bb       	out	0x17, r24	; 23
			PORTB = (1<<6);
 368:	88 bb       	out	0x18, r24	; 24
			break;
 36a:	03 c0       	rjmp	.+6      	; 0x372 <meres+0x60>
		case R1M:
			DDRB =  (1<<7);
 36c:	80 e8       	ldi	r24, 0x80	; 128
 36e:	87 bb       	out	0x17, r24	; 23
			PORTB = (1<<7);
 370:	88 bb       	out	0x18, r24	; 24
			break;
	};

	while (megmerte == FOLYAMATBAN);
 372:	80 91 9c 00 	lds	r24, 0x009C
 376:	81 30       	cpi	r24, 0x01	; 1
 378:	e1 f3       	breq	.-8      	; 0x372 <meres+0x60>
	cli();
 37a:	f8 94       	cli
	
	if (megmerte == TULCSORDULAS){
 37c:	80 91 9c 00 	lds	r24, 0x009C
 380:	82 30       	cpi	r24, 0x02	; 2
 382:	41 f0       	breq	.+16     	; 0x394 <meres+0x82>
		//nem sikerult a meres	
		return TULCSORDULAS;
	}
	
	mert_ido = TCNT1;
 384:	8c b5       	in	r24, 0x2c	; 44
 386:	9d b5       	in	r25, 0x2d	; 45
 388:	90 93 9e 00 	sts	0x009E, r25
 38c:	80 93 9d 00 	sts	0x009D, r24
	return KESZ;
 390:	80 e0       	ldi	r24, 0x00	; 0
 392:	08 95       	ret
	while (megmerte == FOLYAMATBAN);
	cli();
	
	if (megmerte == TULCSORDULAS){
		//nem sikerult a meres	
		return TULCSORDULAS;
 394:	82 e0       	ldi	r24, 0x02	; 2
	}
	
	mert_ido = TCNT1;
	return KESZ;
}
 396:	08 95       	ret

00000398 <main>:
 398:	8f ec       	ldi	r24, 0xCF	; 207
 39a:	97 e0       	ldi	r25, 0x07	; 7
 39c:	01 97       	sbiw	r24, 0x01	; 1
 39e:	f1 f7       	brne	.-4      	; 0x39c <main+0x4>
 3a0:	00 c0       	rjmp	.+0      	; 0x3a2 <main+0xa>
 3a2:	00 00       	nop

int main(void){
	_delay_ms(1);
	//LCD inicializ√°l√°sa, bekapcsolja a kijelz≈ët, √©s egy villog√≥ kurzort helyez a bal fels≈ë sarokba
	lcd_init(LCD_DISP_ON);
 3a4:	8c e0       	ldi	r24, 0x0C	; 12
 3a6:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <lcd_init>
	//Udvozlo szoveg kiirasa LCD-re
	lcd_puts(helloString);
 3aa:	88 e8       	ldi	r24, 0x88	; 136
 3ac:	90 e0       	ldi	r25, 0x00	; 0
 3ae:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_puts>
	
	initUART();
 3b2:	0e 94 31 01 	call	0x262	; 0x262 <initUART>
	UARTWriteString("\r\n\r\n");
 3b6:	87 e7       	ldi	r24, 0x77	; 119
 3b8:	90 e0       	ldi	r25, 0x00	; 0
 3ba:	0e 94 3f 01 	call	0x27e	; 0x27e <UARTWriteString>
	UARTWriteString(helloString);
 3be:	88 e8       	ldi	r24, 0x88	; 136
 3c0:	90 e0       	ldi	r25, 0x00	; 0
 3c2:	0e 94 3f 01 	call	0x27e	; 0x27e <UARTWriteString>
	// ACI:   Analog Comparator Interrupt Flag        (ACSR.4)
	// ACIE:  Analog Comparator Interrupt Enable      (ACSR.3)
	// ACIC:  Analog Comparator Input Capture Enable  (ACSR.2)
	// ACIS0: Analog Comparator Interrupt Mode Select (ACSR.1)
	// ACIS1: Analog Comparator Interrupt Mode Select (ACSR.0)*/
	ACSR= (1<<ACBG) | (1<<ACIE) | (1<<ACIS1); //analog komparator bekapcsolva
 3c6:	8a e4       	ldi	r24, 0x4A	; 74
 3c8:	88 b9       	out	0x08, r24	; 8
	
	// ACME: Analog Comparator Multiplexer Enable     (SFIOR.3)
	SFIOR&= ~(1 << ACME); //disable
 3ca:	80 b7       	in	r24, 0x30	; 48
 3cc:	87 7f       	andi	r24, 0xF7	; 247
 3ce:	80 bf       	out	0x30, r24	; 48

	PORTA = (1<<2);
 3d0:	84 e0       	ldi	r24, 0x04	; 4
 3d2:	8b bb       	out	0x1b, r24	; 27
 3d4:	9f ef       	ldi	r25, 0xFF	; 255
 3d6:	20 e7       	ldi	r18, 0x70	; 112
 3d8:	82 e0       	ldi	r24, 0x02	; 2
 3da:	91 50       	subi	r25, 0x01	; 1
 3dc:	20 40       	sbci	r18, 0x00	; 0
 3de:	80 40       	sbci	r24, 0x00	; 0
 3e0:	e1 f7       	brne	.-8      	; 0x3da <main+0x42>
 3e2:	00 c0       	rjmp	.+0      	; 0x3e4 <main+0x4c>
 3e4:	00 00       	nop
	_delay_ms(100);
	
	switch (meres(R100K)){
 3e6:	81 e0       	ldi	r24, 0x01	; 1
 3e8:	0e 94 89 01 	call	0x312	; 0x312 <meres>
 3ec:	88 23       	and	r24, r24
 3ee:	39 f0       	breq	.+14     	; 0x3fe <main+0x66>
 3f0:	82 30       	cpi	r24, 0x02	; 2
 3f2:	59 f4       	brne	.+22     	; 0x40a <main+0x72>
		case TULCSORDULAS: UARTWriteString("Tulcsordult"); break;
 3f4:	8c e7       	ldi	r24, 0x7C	; 124
 3f6:	90 e0       	ldi	r25, 0x00	; 0
 3f8:	0e 94 3f 01 	call	0x27e	; 0x27e <UARTWriteString>
 3fc:	06 c0       	rjmp	.+12     	; 0x40a <main+0x72>
		case KESZ: lcd_putint(mert_ido); break;
 3fe:	80 91 9d 00 	lds	r24, 0x009D
 402:	90 91 9e 00 	lds	r25, 0x009E
 406:	0e 94 49 00 	call	0x92	; 0x92 <lcd_putint>
			};
		}
		if (!vege)
			UARTWriteString("Tul angy kapacitas\n\r");
	}*/
}
 40a:	80 e0       	ldi	r24, 0x00	; 0
 40c:	90 e0       	ldi	r25, 0x00	; 0
 40e:	08 95       	ret

00000410 <__umulhisi3>:
 410:	a2 9f       	mul	r26, r18
 412:	b0 01       	movw	r22, r0
 414:	b3 9f       	mul	r27, r19
 416:	c0 01       	movw	r24, r0
 418:	a3 9f       	mul	r26, r19
 41a:	70 0d       	add	r23, r0
 41c:	81 1d       	adc	r24, r1
 41e:	11 24       	eor	r1, r1
 420:	91 1d       	adc	r25, r1
 422:	b2 9f       	mul	r27, r18
 424:	70 0d       	add	r23, r0
 426:	81 1d       	adc	r24, r1
 428:	11 24       	eor	r1, r1
 42a:	91 1d       	adc	r25, r1
 42c:	08 95       	ret

0000042e <_exit>:
 42e:	f8 94       	cli

00000430 <__stop_program>:
 430:	ff cf       	rjmp	.-2      	; 0x430 <__stop_program>
